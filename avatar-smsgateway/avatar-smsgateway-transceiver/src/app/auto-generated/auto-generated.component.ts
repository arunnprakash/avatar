import { Component, OnInit, AfterViewInit } from '@angular/core';
import * as TNSInbox from 'nativescript-sms-inbox';
import * as TNSPhone from 'nativescript-phone';
import { HttpClient, HttpParams, HttpRequest, HttpErrorResponse } from '@angular/common/http';
import { Observable, of, throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { SendSmsDTO } from './outgoingsmsdto.model';
import { ReceivedSmsDTO } from './incomingsmsdto.model';
import * as _ from "lodash";

@Component({
  selector: 'app-auto-generated',
  templateUrl: './auto-generated.component.html',
  styleUrls: ['./auto-generated.component.css']
})
export class AutoGeneratedComponent implements OnInit {

    private readingInbox: boolean = false;
    private checkingSendSms: boolean = false;

  constructor(private httpClient: HttpClient) { }

  ngOnInit() {
  }
 
  ngAfterViewInit() {
      setInterval(()=> { 
          this.readInbox(); }, 4000); 
      setInterval(()=> { 
          this.checkSendSms(); }, 4000);
      
  }
  readInbox() {
      if (!this.readingInbox) {
          this.readingInbox = true;
          let fromNumber: string = "0712345678";
          TNSInbox.getInboxesFromNumber(fromNumber, { max: 10 }).then((res) => {
              console.log(res);
              let receivedSmsDTO: ReceivedSmsDTO = new ReceivedSmsDTO();
              receivedSmsDTO.message = res;
              this.pushToSmsGateway(receivedSmsDTO).subscribe((result: any) => {
                  console.log("Received Sms pushed to Offline Service", result);
                  this.readingInbox = false;
              });
                  
          }, (err) => {
              console.log('Error: ' + err);
              this.readingInbox = false;
          });
      }
  }
  checkSendSms() {
      if (!this.checkingSendSms) {
          this.checkingSendSms = true;
          this.getSendSmsList().subscribe((sendSmsList: SendSmsDTO[]) => {
              sendSmsList.forEach( (sendSms: SendSmsDTO ) => {
                  TNSPhone.sms(sendSms.receipients, sendSms.message)
                  .then((args) => {
                      console.log("sms send successfully");
                  }, (err) => {
                      console.log('Error: ' + err);
                  });
              });
              this.checkingSendSms = false;
          },
          ( error ) => {
             console.log('Error', 'Error while getting WareHouse List');
             this.checkingSendSms = false;
          });
      }
  }
  pushToSmsGateway(receivedSmsDTO: ReceivedSmsDTO): Observable<any> {
      const url = 'http://192.168.1.181:2050/receive-sms';
      return this.httpClient.post<string>(url, receivedSmsDTO)
          .pipe(catchError(this.handleError));
  }
  getSendSmsList(): Observable<SendSmsDTO[]> {
      const url = 'http://192.168.1.181:2050/get-send-sms-list';
      return this.httpClient.get<SendSmsDTO[]>(url)
          .pipe(catchError(this.handleError));
  }
  
  private handleError(error: HttpErrorResponse) {
      // in a real world app, we may send the error to some remote logging infrastructure
      // instead of just logging it to the console
      //this.log('error', error);

      return throwError(error);
  }
}
